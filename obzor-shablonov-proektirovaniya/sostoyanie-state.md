# Состояние \(State\)

Пришло время исповедаться: я немного перестарался с этой главной. Предполагалось что она посвящена шаблону проектирования [Состояние (State)GOF](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) . Но я не могу говорить о его применении в играх не затрагивая концепцию _конечных автоматов (finite state machines) (или "FSM")_. Но как только я в нее углубился, я понял что мне придется вспомнить _иерархическую машину состояний (hierarchical state machine) или иерархический автомат_ и _автомат с магазинной памятью(pushdown automata)_.

Тематика получается слишком обширной, поэтому чтобы сократить главу до минимума я буду опускать некоторые очевидные фрагменты примеров кода и вам придется заполнить некоторые пропуски самостоятельно. Я надеюсь это не сделает их менее понятными.

Не нужно расстраиваться если вы никогда не слышали про конечные автоматы. Они хорошо известны разработчикам AI и компьютерным хакерам, но малоизвестны в других областях. На мой взгляд они заслуживают большей известности, так что я хочу продемонстрировать вам несколько проблем, которые они решают.

> Все это отголоски старых ранних деньков искусственного интеллекта. В 50-е и 60-е искусственный интеллект в основном фокусировался на обработке языковых конструкций. Многие используемые в современных компиляторах технологии были изобретены для парсинга человеческих языков.

## Все мы там были

Допустим мы работаем над небольшим платформером сайд-скроллером. Наша задача заключается в моделировании героини, которая будет аватаром игрока в игровом мире. Это значит что она должна реагировать на пользовательский ввод. Нажмите B и она прыгнет. Довольно просто:

```cpp
void Heroine::handleInput(Input input)
{
    if (input == PRESS_B)
    {
        yVelocity_ = JUMP_VELOCITY;
        setGraphics(IMAGE_JUMP);
    }
}
```

Заметили баг?

Здесь нет никакого кода, предотвращающего "прыжок в воздухе"; продолжайте нажимать B пока она в воздухе и она будет подлетать снова и снова. Проще всего решить это добавлением булевского флага `isJumping_` в `Heroine`, который будет следить за тем когда героиня прыгнула:

```cpp
void Heroine::handleInput(Input input)
{
    if (input == PRESS_B)
    {
        if (!isJumping_)
        {
            isJumping_ = true;
            // Прыжок...
        }
    }
}
```

> Нам нужен еще и код, который будет устанавливать `isJumping_` обратно в `false` когда героиня снова коснется земли. Для простоты я опускаю этот код.



Дальше мы захотели добавить героине игрока возможность пригибаться, когда она находится на земле и вставать когда кнопка отжимается:

```cpp
void Heroine::handleInput(Input input)
{
    if (input == PRESS_B)
    {
        // Прыгаем если уже не прыгнули...
    }
    else if (input == PRESS_DOWN)
    {
        if (!isJumping_)
        {
            setGraphics(IMAGE_DUCK);
        }
    }
    else if (input == RELEASE_DOWN)
    {
        setGraphics(IMAGE_STAND);
    }
}
```

А здесь баг заметили?

С помощью этого кода игрок может:

1. Нажать вниз для приседания.
1. Нажать B для прыжка из сидячей позиции.
1. Отпустить вниз, находясь в воздухе.

При этом героиня переключится на графику стояния прямо в воздухе. Придется добавить еще один флаг...

```cpp
void Heroine::handleInput(Input input)
{
    if (input == PRESS_B)
    {
        if (!isJumping_ && !isDucking_)
        {
            // Прыжок...
        }
    }
    else if (input == PRESS_DOWN)
    {
        if (!isJumping_)
        {
            isDucking_ = true;
            setGraphics(IMAGE_DUCK);
        }
    }
    else if (input == RELEASE_DOWN)
    {
        if (isDucking_)
        {
            isDucking_ = false;
            setGraphics(IMAGE_STAND);
        }
    }
}
```

Теперь будет здорово добавить героине способность атаковать подкатом, когда игрок нажимает вниз, находясь в воздухе:

```cpp
void Heroine::handleInput(Input input)
{
    if (input == PRESS_B)
    {
        if (!isJumping_ && !isDucking_)
        {
            // Прыжок...
        }
    }
    else if (input == PRESS_DOWN)
    {
        if (!isJumping_)
        {
            isDucking_ = true;
            setGraphics(IMAGE_DUCK);
        }
        else
        {
            isJumping_ = false;
            setGraphics(IMAGE_DIVE);
        }
    }
    else if (input == RELEASE_DOWN)
    {
        if (isDucking_)
        {
            // Стояние...
        }
    }
}
```

Снова ищем баги. Нашли?

У нас есть проверка на то чтобы было невозможно прыгнуть в воздухе, но не во время подката. Добавляем еще один флаг...

Есть в этом подходе что-то неправильное. Каждый раз когда мы касаемся кода, у нас что-то ломается. Нам понадобится добавить еще кучу движения, у нас ведь еще даже _ходьбы_ нет, но при таком подходе нам придется преодолеть еще кучу багов.

## Конечные автоматы - наше спасение

Чтобы окончательно не впасть во фрустрацию, вы убираете со стола все кроме карандаша и бумажки и начинаете чертить блок-схему. Рисуем прямоугольник для каждого действия, что может совершить героиня: стояние, прыжок, приседание и подкат. Чтобы она могла реагировать на нажатие клавиш в любом из состояний, рисуем стрелки между этими прямоугольниками, подписываем над ними кнопки и соединяем между собой состояния.

> Программисты которых мы все идеализируем и которые создают отличный код на самом деле совсем не супермены. Они просто развили в себе чутье на _угрожающий_ появлением ошибок код и стараются по возможности его избегать.
>
> Сложное ветвление и изменяющиеся состояния - это как раз и есть те типы кода, которых стоит избегать.

![2-6-1.1](../assets/2-6-1.1.png)

Поздравляю, вы только что создали _конечный автомат (finite state machine)_. Они пришли из области компьютерных наук, называемой _теория автоматов (automata theory)_, в семейство структур которой также входит знаменитая машина Тьюринга. FSM - простейший член этого семейства.

Суть заключается в следующем:

- У нас есть фиксированный набор _состояний_, в которых может находиться автомат. В нашем примере это стояние, прыжок, приседание и подкат.
- Автомат может находиться только в _одном_ состоянии в каждый момент времени. Наша героиня не может прыгать и стоять одновременно. Собственно для того чтобы это предотвратить FSM в первую очередь и используется.
- Последовательность _ввода_ или _событий_, передаваемых автомату. В нашем примере это нажатие и отпускание кнопок.
> Моя любимая аналогия FSM - это старый текстовый квест [Zork](https://ru.wikipedia.org/wiki/Zork). У вас есть мир, состоящий из комнат, которые соединены между собой переходами. И вы можете исследовать их, вводя команды типа "идти на север".
>
> Такая карта полностью соответствует определению конечного автомата. Комната, в которой вы находитесь - это текущее состояние. Каждый выход из комнаты - переход. Навигационные команды - ввод.

- Каждое состояние имеет набор _переходов_, каждый из которых связан с вводом и указывает на состояние. Когда происходит пользовательский ввод, если он соответствует текущему состоянию, автомат меняет свое состояние на то куда указывает _стрелка_.

  Например если нажать вниз в состоянии стояния, произойдет переход в состояние приседания. Нажатие вниз во время прыжка меняет состояние на подкат. Если в текущем состоянии никакой переход для ввода не предусмотрен - ничего не происходит.

В чистой форме это и есть целый банан: состояния, ввод и переходы. Можно изобразить их в виде блок-схемы. К сожалению компилятор таких каракулей не поймет. Так как же в таком случае _реализовать_ конечный автомат? Банда четырех предлагает свой вариант, но начнем мы с еще более простого.

## Перечисления и переключатели

Одна из проблем нашего старого класса Heroine заключается в том что он допускает некорректную комбинацию булевских ключей: `isJumping_` и `isDucking_` не могут быть правдой одновременно. А если у вас есть несколько булевских флагов, только один из которых может быть `true`, не лучше ли заменить их все на `enum`.

В нашем случае с помощью enum можно полностью описать все состояния нашей FSM таким образом:

```cpp
enum State
{
    STATE_STANDING,
    STATE_JUMPING,
    STATE_DUCKING,
    STATE_DIVING
};
```

Вместо кучи флагов, у `Heroine` есть только одно поле `state_`. Также нам придется изменить порядок ветвления. В предыдущем примере кода, мы делали ветвление сначала в зависимости от ввода, а _потом_ уже от состояния. При этом мы группировали код по нажатой кнопке, но размывали код, связанный с состояниями. Теперь мы сделаем наоборот и будем переключать ввод в зависимости от состояния. Получим мы вот что:

```cpp
void Heroine::handleInput(Input input)
{
    switch (state_)
    {
        case STATE_STANDING:
            if (input == PRESS_B)
            {
                state_ = STATE_JUMPING;
                yVelocity_ = JUMP_VELOCITY;
                setGraphics(IMAGE_JUMP);
            }
            else if (input == PRESS_DOWN)
            {
                state_ = STATE_DUCKING;
                setGraphics(IMAGE_DUCK);
            }
            break;
    
        case STATE_JUMPING:
            if (input == PRESS_DOWN)
            {
                state_ = STATE_DIVING;
                setGraphics(IMAGE_DIVE);
            }
            break;
            
        case STATE_DUCKING:
            if (input == RELEASE_DOWN)
            {
                state_ = STATE_STANDING;
                setGraphics(IMAGE_STAND);
            }
            break;
    }
}
```

Выглядит довольно тривиально, но тем не менее этот код уже гораздо лучше, чем предыдущий. У нас остались некоторые условные ветвления, но зато мы упростили изменяемое состояние до единственного поля. Весь код, управляющий единственным состоянием собран в одном месте. Это самый простой способ реализации конечного автомата и иногда его вполне достаточно.

> Теперь героиня уже не сможет быть в _неопределенном_ состоянии. При использовании булевых флагов некоторые комбинации были возможны, но не имели смысла. При использовании enum все значения корректны.

К сожалению ваша проблема может перерасти такое решение. Допустимо мы захотели добавить нашей героине специальную атаку, для проведения которой героине нужно присесть для подзарядки и потом разрядить накопленную энергию. И пока мы сидим, нам нужно следить за верменем зарядки.

Добавляем в Heroine поле `chargeTime_` для хранения времени зарядки. Допустим у нас уже есть метод `update()`, вызываемый на каждом кадре. Добавим в него следующий код:

> Если вы угадали что это шаблон [Метод Обновления (Update Method)](/posledovatelnie-shabloni-sequencing-patterns/metodi-obnovleniya-update-methods.md) вы выиграли приз!

```cpp
void Heroine::update()
{
    if (state_ == STATE_DUCKING)
    {
        chargeTime_++;
        if (chargeTime_ > MAX_CHARGE)
        {
            superBomb();
        }
    }
}
```

Каждый раз когда мы приседаем заново нам нужно обнулять этот таймер. Для этого нам нужно изменить `handleInput()`:

```cpp
void Heroine::handleInput(Input input)
{
    switch (state_)
    {
        case STATE_STANDING:
            if (input == PRESS_DOWN)
            {
                state_ = STATE_DUCKING;
                chargeTime_ = 0;
                setGraphics(IMAGE_DUCK);
            }
            // Обработка оставшегося ввода...
            break;
        
        // Другие состояния...
    }
}
```

В конце концов для добавления этой атаки с подзарядкой нам пришлось изменить два метода и добавить поле `chargeTime_` в `Heroine`, даже если оно используется только в состоянии приседания. Хотелось бы иметь весь этот код и данные в одном месте. Банда четырех может нам в этом помочь.

## Шаблон состояние

Для людей, хорошо разбирающихся в объектно-ориентированной парадигме, каждое условное ветвление - это возможность для использования динамической диспетчеризации (другими словами вызова виртуального метода в C++). Думаю нам нужно спуститься в эту кроличью нору еще глубже. Иногда `if` - это все что нам нужно.

В нашем примере мы уже добрались до той критической точки, когда нам стоит обратить внимание на что-то объектно-ориентированное. Это подводит нас к шаблону Состояние. Цитирую банду четырех:

> Этому есть историческое обоснование. Многие из старых апостолов объектно-ориентированной парадигмы, такие как банда четырех со своими Паттернами программирования и Мартин Фулер с его Рефакторингом пришли из Smalltalk. А там `ifThen:` - это всего лишь метод, которым вы обрабатываете условие и который реализуется по разному для объектов `true` и `false`.

_Позволяет объектам менять свое поведение в соответствии с изменением внутреннего состояния. При этом объект будет вести себя как другой класс._

Не очень то и понятно. В конце концов и `switch` с этим справляется. Применительно к нашему примеру с героиней шаблон будет выглядеть следующим образом:

### Интерфейс состояния

Для начала определим интерфейс для состояния. Каждый бит поведения, зависящий от состояния - т.е. все что мы раньше реализовывали при помощи switch - превращается в виртуальный метод этого интерфейса. В нашем случае это handleInput() и update().

```cpp
class HeroineState
{
    public:
        virtual ~HeroineState() {}
        virtual void handleInput(Heroine& heroine, Input input) {}
        virtual void update(Heroine& heroine) {}
};
```

### Классы для каждого из состояний

Для каждого состояния мы определяем класс, реализующий интерфейс. Его методы определяют поведение героини в данном состоянии. Другими словами берем все варианты из `switch` в предыдущем примере превращаем их в класс состояния. Например:

```cpp
class DuckingState : public HeroineState
{
    public:
        DuckingState() : chargeTime_(0) {}
        
        virtual void handleInput(Heroine& heroine, Input input) {
            if (input == RELEASE_DOWN)
            {
                // Переход в состояние стояния...
                heroine.setGraphics(IMAGE_STAND);
            }
        }
        
        virtual void update(Heroine& heroine) {
            chargeTime_++;
            if (chargeTime_ > MAX_CHARGE)
            {
                heroine.superBomb();
            }
        }
    
    private:
        int chargeTime_;
};
```

Обратите внимание что мы перенесли `chargeTime_` из класса самой героини в класс `DuckingState`. И это очень хорошо, потому что этот кусок данных имеет значение только в этом состоянии и наша модель данных явно об этом свидетельствует.

### Делегирование к состоянию


Дальше мы даем `Heroine` указатель на текущее состояние, избавляемся от здоровенного switch и делегируем его работу состоянию.

```cpp
class Heroine
{
    public:
        virtual void handleInput(Input input)
        {
            state_->handleInput(*this, input);
        }
        
        virtual void update()
        {
            state_->update(*this);
        }
        
        // Другие методы...
    private:
        HeroineState* state_;
};
```

Чтобы "изменить состояние" нам нужно просто сделать так чтобы `state_` указывал на другой объект `HeroineState`. В этом собственно и заключается шаблон Состояние.

Выглядит довольно похоже на шаблоны [Стратегия (Strategy) GOF](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) и [Объект тип (Type Object)](/povedencheskie-shabloni-behavioral-patterns/obekt-tip-type-object.md). Во всех трех у нас есть главный объект, делегирующий к подчиненному. Различие в _назначении_.


- Цель Стратегии заключается в уменьшении связности (decouple) между главным классом и его поведением.

- Целью Объект тип (Type Object) является создание некоторого количества объектов, ведущих себя одинаково с помощью разделения между собой общего объекта типа.

- Целью Состояния является изменение поведения главного объекта через изменение объекта к которому он делегирует.

## А где же эти объекты состояния?


Я вам кое-что не сказал. Чтобы изменить состояние, нам нужно присвоить `state_` новое значение, указывающее на новое состояние, но откуда этот объект возьмется? В нашем примере с enum думать не о чем: значения enum - это просто примитивы наподобие чисел. Но теперь наши состояния представлены классами и это значит что нам нужны указатели на реальные экземпляры. Существует два самых распространенных ответа:

### Статические состояния

Если объект состояния не имеет никаких других полей, единственное что он хранит - это указатель на внутреннюю виртуальную таблицу методов для того чтобы эти методы можно было вызвать. В таком случае нет никакой необходимости иметь больше одного экземпляра класса: каждый из экземпляров все равно будет одинаковым.

> Если у вашего состояния нет полей и только один виртуальный метод, можно еще сильнее упростить шаблон. Заменим каждый _класс_ состояния _функцией_ состояния - обычной функцией верхнего уровня. И соответственно поле `state_` в нашем главном классе превратится в простой указатель на функцию.

Вполне можно обойтись единственным _статическим_ экземпляром. Даже если у вас целая куча FSM, находящихся одновременно в одном и том же состоянии, они могут указывать на один и тот же статический экземпляр, потому что ничего специфичного для конкретного конечного автомата в нем нет.

> Получился шаблон [Приспособленец(Flyweight Pattern)GOF](/obzor-shablonov-proektirovaniya/prisposoblenets-flyweight.md)


_Куда_ вы поместите статический экземпляр - это уже ваше дело. Найдите такое место, где это будет уместно. Давайте поместим наш экземпляр в базовый класс. Без всякой причины.

```cpp
class HeroineState
{
    public:
        static StandingState standing;
        static DuckingState ducking;
        static JumpingState jumping;
        static DivingState diving;
        
        // Остальной код...
};
```

Каждое из этих статических полей - экземпляр состояния, используемого игрой. Чтобы заставить героиню подпрыгнуть, состояние стояния сделает нечто вроде:

```cpp
if (input == PRESS_B)
{
    heroine.state_ = &HeroineState::jumping;
    heroine.setGraphics(IMAGE_JUMP);
}
```

### Экземпляры состояний


Иногда предыдущий вариант не взлетает. Статическое состояние не подойдет для состояния присядки. У него есть поле `chargeTime_` и оно специфично для героини, которая будет приседать. Это еще худо бедно сработает в нашем случае, потому что у нас всего одна героиня, но если мы захотим добавить кооператив для двух игроков, у нас будут большие проблемы.

В таком случае нам следует создать объект состояния и передать его следующим образом:

> Когда вы выделяете память под состояние динамически, вам стоит подумать о возможной фрагментации памяти. Помочь может шаблон [Пул объектов (Object Pool)](/shabloni-optimizatsii/pul-obektov-object-pool.md)

```cpp
// Состояние стояния:
if (input == PRESS_DOWN)
{
    delete heroine.state_;
    heroine.state_ = new DuckingState();
    // Остальной код...
}
```

Это позволит каждому FSM иметь собственный экземпляр состояния. Когда у меня получается я предпочитаю использовать статические состояния, потом что они не занимают память и такты процессора, выделяя объекты при каждом изменении состояния. Для состояний, которые не представляют из себя _нечто большее_, чем просто состояние - это как раз то что нужно.

## Действия для входа и выхода

Шаблон Состояние предназначен для инкапсуляции всего поведения и связанных с ним данных внутри одного класса. У нас довольно неплохо получается, но остались некоторые невыясненные детали. Мы перенесли в `DuckingState` обработку пользовательского ввода и обновление времени подзарядки, но весь связанный с приседанием код остался снаружи. Там же в состоянии стояния, где мы _начинаем_ приседать, выполняется и инициализация:

```cpp
// В стоячем состоянии:
if (input == PRESS_DOWN)
{
    // Состояние зарядки...
    chargeTime_ = 0;
    setGraphics(IMAGE_DUCK);
}
```

Состояние приседания должно само позаботиться о сбросе времени зарядки (в конце концов именно в этом объекте находится это поле) и проигрывании анимации. Мы можем добиться этого, добавив в состояние _входное действие (entry action)_:

```cpp
class DuckingState : public HeroineState
{
    public:
        virtual void enter(Heroine& heroine)
        {
            chargeTime_ = 0;
            heroine.setGraphics(IMAGE_DUCK);
        }
    
        // Остальной код...
};
```

Возвращаясь к `Heroine` мы поместим изменение состояния внутрь удобного метода, в который будет передаваться новое состояние:

```cpp
void Heroine::changeState(HeroineState* state)
{
    delete state_;
    state_ = state;
    state_->enter(*this);
}
```

Для кода стояния это будет выглядеть следующим образом:

```cpp
if (input == PRESS_DOWN)
{
    heroine.changeState(new DuckingState());
}
```

Теперь приседание действительно инкапсулировано. Еще одной приятной особенностью такого входного действия является то что оно запускается при входе в состояние независимо от состояния в котором мы _находились_.

На большинстве графов состояний из реальной жизни присутствует несколько переходов в одно и то же состояние. Например, наша героиня может стрелять из оружия стоя, сидя или в прыжке. А это значит что у нас может появиться дублирование кода везде где это происходит. Входное действие позволяет собрать его в одном месте.

Можно по аналогии сделать и _выходное действие (exit action)_. Это будет просто метод, котрый мы будем вызывать для состояния, перед тем как _покидаем_ его и переключаемся на новое состояние.

## И чего же мы добились?


Я столько времени потратил чтобы продать вам FSM, а теперь собираюсь вырвать коврик из под ног. Все что я до сих пор говори правда и отлично решает проблемы. Но так уж вышло что самые главные достоинства конечных автоматов одновременно являются и их самыми большими недостатками.

Состояние автомата помогает вам серьезно распутать код, организовав его в крайне строгую структуру. Все что у нас есть - это фиксированный набор состояний, единственное текущее состояние и жестко запрограммированные переходы.

Если же вы попробуете использовать машину состояний для чего-либо более сложного, как например игровой AI, вы сразу уткнетесь в ограничения этой модели. К счастью наши предшественники научились обходить некоторые препятствия. Я закончу эту главу несколькими такими примерами.

> Конечный автомат не обладает _полнотой по Тьюрингу (Turing complete)_. Теория автоматов описывает полноту через серию абстрактных моделей, каждая из которых сложнее предыдущей. _Машина Тьюринга_ - одна из самых выразительных.
>
> "Полнота по Тьюригну" означает систему (обычно язык программирования), обладающую достаточной выразительностью для реализации машины Тьюринга. В свою очередь это означает что все полные по Тьюрингу языки примерно одинаково выразительны. FSM недостаточно выразительны чтобы войти в этот клуб.



## Машина конкурентных состояний или конкурентный автомат (Concurrent State Machines)

Мы решили добавить нашей героине возможность носить оружие. Хотя она теперь вооружена, она по прежнему может делать все что делала раньше: бегать, прыгать, приседать и т.д. Но теперь делая все это она еще может и стрелять из оружия.

Если мы захотим вместить такое поведение в рамки FSM, нам придется _удвоить_ количество состояний. Для каждого из состояний нам придется завести еще одно такое же, но уже для героини с оружием: стояние, стояние с оружием, прыжок, прыжок с оружием.... Ну вы поняли.

Если добавить еще несколько видов оружия, количество состояний увеличится комбинаторно. И это не просто куча состояний, а еще и куча повторов: вооруженное и безоружное состояния практически идентичны за исключением части кода, отвечающей за стрельбу.

Проблема здесь в том что мы смешиваем две части состояния - что мы _делаем_ и что _держим_ в руках в один автомат. Чтобы смоделировать все возможные комбинации нам нужно завести состояние для каждой _пары_. Решение очевидно: нужно завести два отдельных конечных автомата.

> Если мы хотим объединить n состояний действия и n состояний того что держим в руках в один конечный автомат - нам нужно n*m состояний. Если у нас будет два автомата - нам понадобится n+m состояний.


Наш первый конечный автомат с действиями мы оставим без изменений. А в дополнение к нему создадим еще один автомат для описания того что героиня держит. Теперь у `Heroine` будет две ссылки на "состояние", по одной для каждого автомата.

```cpp
class Heroine
{
    // Остальной код...
    
    private:
        HeroineState* state_;
        HeroineState* equipment_;
};
```

> Для иллюстрации мы используем полную реализацию шаблона Состояние для второго конечного автомата, хотя на практике в данном случае хватило бы простого булевского флага.

Когда героиня делегирует ввод состояниям, она передает перевод обеим конечным автоматам:

```cpp
void Heroine::handleInput(Input input)
{
    state_->handleInput(*this, input);
    equipment_->handleInput(*this, input);
}
```

Каждый конечный автомат может реагировать на ввод, порождать поведение и изменять свое состояние независимо от других автоматов. И когда оба состояния практически не связаны между собой это отлично работает.

> Более сложные системы могут иметь в своем составе конечные автоматы, которые могут _поглощать_ часть ввода таким образом чтобы другие автоматы его уже не получали. Это позволит нам предотвратить ситуацию, когда несколько автоматов реагируют на один и тот же ввод.

На практике вы можете встретить ситуацию, когда состояния взаимодействуют друг с другом. Например, она не может выстрелить в прыжке или например выполнить атаку с подкатом когда вооружена.Чтобы обеспечить такое поведение и координацию автоматов в коде, вам придется вернуться к той же самой грубой проверке через if другого конечного автомата. Не самое элегантное решение, но по крайней мере работает.

## Иерархическая машина состояний или иерархический автомат

После дальнейшего оживления поведения героини, у нее наверняка появится целый букет похожих состояний. Например у не могут быть состояния стояния, ходьбы, бега и скатывания со склонов. В любом из этих состояний нажатие на B заставляет ее подпрыгнуть., а нажатие вниз - присесть.

В простейшей реализации конечного автомата мы дублировали этот код для всех состояний. Но конечно было бы гораздо лучше если бы нам нужно было написать код всего один раз и после этого мы могли бы использовать его повторно для всех состояний.

Если бы это был просто объектно-ориентированный код, а не конечный автомат, можно было бы использовать такой прием разделения кода между состояниями, как наследование. Можно определить класс для состояния "на земле", который будет обрабатывать подпрыгивание и приседание. Стояние, ходьба, бег и скатывание для него наследуется и добавляет свое дополнительное поведение.

В таком виде получившаяся структура будет называться _иерархическая машина состояний_ или _иерархический автомат_. А у каждого состояния может быть свое "_суперсостояние_" (само состояние при этом называется "_подсостоянием_"). Когда наступает событие и подсостояние его не обрабатывает, оно передается по цепочке суперсостояний вверх. Другими словами получается подобие переопределения унаследованного метода.

> Такое решение имеет как хорошие, так и плохие последствия. Наследование - это мощный инструмент для повторного использования кода, но в то же время оно дает очень сильную связность между двумя кусками кода. Молот слишком тяжел чтобы бить им бездумно.

На самом деле если мы используем оригинальный шаблон Состояние для реализации FSM, мы уже можем использовать наследование классов для реализации иерархии. Определим базовый класс для суперкласса:

```cpp
class OnGroundState : public HeroineState
{
    public:
        virtual void handleInput(Heroine& heroine, Input input)
        {
            if (input == PRESS_B)
            {
                // Подпрыгнуть...
            }
            else if (input == PRESS_DOWN)
            {
                // Присесть...
            }
        }
};
```

А теперь каждый подкласс будет его наследовать:

```cpp
class DuckingState : public OnGroundState
{
    public:
        virtual void handleInput(Heroine& heroine, Input input)
        {
            if (input == RELEASE_DOWN)
            {
                // Встаем...
            }
            else
            {
                // Ввод не обработан. Поэтому передаем его выше по иерархии.
                OnGroundState::handleInput(heroine, input);
            }
        }
};
```

Конечно это не единственный способ реализации иерархии. Но если вы не используете шаблон Состояние банды четырех, это не сработает. Вместо этого вы можете смоделировать четкую иерархию текущих состояний и суперсостояний с помощью стека состояний вместо единственного состояния в главном классе.

Текущее состояние будет находится вверху стека, под ним его суперсостояние, дальше суперсостояние для _этого_ суперсостояния и т.д. И когда вам нужно будет реализовать специфичное для состояния поведение, вы начнете с верха стека спускаться по нему вниз, пока состояние его не обработает. (А если не обработает - значит вы его просто игнорируете).

## Автомат с магазинной памятью (Pushdown Automata)

Есть еще одно обычное расширение конечных автоматов, также использующее стек состояния. Только здесь стек представляет совершенно другую концепцию и используется для решения других проблем.

Проблема в том что у конечного автомата нет концепции _истории_. Вы знаете в каком состоянии вы _находитесь_, но у вас нет никакой информации о том в каком состоянии вы _были_. И соответственно нет простой возможности вернуться в предыдущее состояние.

Вот простой пример: Ранее мы позволили нашей бесстрашной героине вооружиться до зубов. Когда она стреляет из своего оружия, нам нужно новое состояние для проигрывания анимации выстрела, порождения пули и сопутствующих визуальных эффектов. Для этого мы создаем новое `FiringState` и делаем в него переходы из всех состояний, в которых героиня может стрелять по нажатию кнопки стрельбы.

Сложность здесь в том что нужно каким либо образом понять в какое состояние нужно перейти _после_ стрельбы. Героиня может выстрелить всю обойму пока она стоит на месте, бежит, прыгает или приседает. Когда последовательность стрельбы закончена, ей нужно вернуться в состояние, в котором она была до стрельбы.

> Так как это поведение дублируется между несколькими состояниями, здесь как раз можно применить иерархическую машину состояний для повторного использования кода.

Если мы привязываемся к чистому FSM, мы сразу забываем в каком состоянии мы были. Чтобы за этим следить нам нужно определить множество практически одинаковых состояний - стрельба стоя, стрельба в беге, стрельба в прыжке и т.д. Таким образом у нас образуются жестко закодированные переходы, переходящие в правильное состояние по своему окончанию.

Что нам на самом деле нужно - так это возможность хранить состояние в котором мы находились до стрельбы и после стрельбы вспоминать его снова. Здесь нам снова может помочь теория автоматов. Соответствующая структура данных называется [Автомат с магазинной памятью (Pushdown Automata)](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D1%81_%D0%BC%D0%B0%D0%B3%D0%B0%D0%B7%D0%B8%D0%BD%D0%BD%D0%BE%D0%B9_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E).

Там где в конечном автомате у нас находится _единственный_ указатель на состояние, в автомате с магазинной памятью находится их _стек_. В FSM переход к новому состоянию заменяет собой предыдущий. Автомат с магазинной памятью тоже позволяет это делать, но добавляет сюда еще две операции:

1. Вы можете поместить (_push_) новое состояние в стек. Текущее состояние всегда будет находиться вверху стека, так что это и есть операция перехода в новое состояние. Но при этом старое состояние остается прямо под текущим в стеке, а не исчезает бесследно.
1. Вы можете извлечь (_pop_) верхнее состояние из стека. Состояние пропадает и текущим становится то что находилось под ним.


![2-6-1.2](../assets/2-6-1.2.png)


Это все что нам нужно для стрельбы. Мы создаем _единственное_ состояние стрельбы. Когда мы нажимаем кнопку стрельбы, находясь в другом состоянии, мы помещаем (_push_) состояние стрельбы в стек. Когда анимация стрельбы заканчивается, мы извлекаем (_pop_) состояние и автомат с магазинной памятью автоматически возвращает нас в предыдущее состояние.

## Насколько они реально полезны?

Даже с этим расширением конечных автоматов, их возможности все равно довольно ограничены. В AI сегодня преобладает тренд использования вещей типа [деревьев поведения (behavior trees)](http://www.altdevblogaday.com/2011/02/24/introduction-to-behavior-trees/) и [систем планирования (planning systems)](http://alumni.media.mit.edu/~jorkin/goap.html). И если вам интересна именно область AI, вся эта глава должна просто раздразнить ваш аппетит. Чтобы его удовлетворить вам придется обратиться к другим книгам.

Это совсем не значит что конечные автоматы, автоматы с магазинной памятью и другие подобные системы полностью бесполезны. Для некоторых вещей это хорошие инструменты для моделирования. Конечные автоматы полезны когда:

- У вас есть сущность, поведение которой изменяется в зависимости от ее внутреннего состояния.

- Это состояние жестко делится на относительно небольшое количество конкретных вариантов.

- Сущность постоянно отвечает на серии команд ввода или событий.

В играх конечные автоматы обычно используются для моделирования AI, но их можно применять и для реализации пользовательского ввода, навигации в меню, парсинга текста, сетевых протоколов и другого асинхронного поведения.